from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from typing import Optional, List, Literal
from datetime import datetime
import uuid

from backend.src.services.rag_service import RAGService
from backend.src.services.gemini_service import GeminiService
from backend.src.services.qdrant_service import QdrantService
from backend.src.models.user_query import UserQuery
from backend.src.models.chatbot_response import ChatbotResponse
from backend.src.models.source_document import SourceDocument # Ensure this is imported for SourceDocument model

router = APIRouter()

# Request model for POST /chat/query
class ChatQueryRequest(BaseModel):
    user_id: str
    query_text: str
    session_id: str

# Response model for GET /chat/sources/{response_id} (already defined, moved here for clarity if needed elsewhere)
# class SourceDocument(BaseModel):
#     document_id: str
#     title: str
#     excerpt: str
#     url: str

# Model for a chat message in history
class Message(BaseModel):
    type: Literal["user", "bot"]
    text: str
    timestamp: datetime
    response_id: Optional[str] = None

# Request model for POST /chat/feedback
class FeedbackRequest(BaseModel):
    response_id: str
    feedback_type: Literal["positive", "negative", "irrelevant", "inaccurate"]
    comment: Optional[str] = None

# Mock storage for chat history
mock_chat_history: List[Message] = [
    Message(type="user", text="Hello chatbot!", timestamp=datetime.utcnow() - timedelta(minutes=5), response_id=None),
    Message(type="bot", text="Hello! How can I help you today?", timestamp=datetime.utcnow() - timedelta(minutes=4), response_id="bot-resp-1"),
    Message(type="user", text="What is ROS2?", timestamp=datetime.utcnow() - timedelta(minutes=3), response_id=None),
    Message(type="bot", text="ROS 2 is the Robot Operating System 2.", timestamp=datetime.utcnow() - timedelta(minutes=2), response_id="bot-resp-2"),
]


# Dependency for RAGService
async def get_rag_service(
    gemini_service: GeminiService = Depends(GeminiService),
    qdrant_service: QdrantService = Depends(QdrantService)
) -> RAGService:
    return RAGService(
        gemini_service=gemini_service,
        qdrant_service=qdrant_service
    )

@router.post("/chat/query", response_model=ChatbotResponse)
async def chat_query(
    request: ChatQueryRequest,
    rag_service: RAGService = Depends(get_rag_service)
):
    """
    Send a natural language query to the chatbot.
    """
    try:
        # Create a UserQuery object from the request
        user_query_obj = UserQuery(
            id=str(uuid.uuid4()),
            user_id=request.user_id,
            text_content=request.query_text,
            timestamp=datetime.utcnow(),
            embedding_vector=[], # This will be generated by RAGService
            session_id=request.session_id
        )

        response = await rag_service.answer_query(user_query_obj)
        
        # Add to mock history (in a real app, this would be persisted to a DB)
        mock_chat_history.append(Message(type="user", text=request.query_text, timestamp=user_query_obj.timestamp, response_id=None))
        mock_chat_history.append(Message(type="bot", text=response.text_content, timestamp=response.timestamp, response_id=response.id))
        
        return response
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {e}"
        )

@router.get("/chat/sources/{response_id}", response_model=List[SourceDocument])
async def get_chat_sources(response_id: str):
    """
    Get source documents for a specific chatbot response.
    """
    # In a real scenario, this would retrieve the ChatbotResponse by response_id
    # then look up the retrieved_chunks_refs and fetch details about them.
    # For now, we return mock data.
    if response_id == "mock-response-id-123":
        return [
            SourceDocument(
                document_id="source-doc-1",
                title="Introduction to ROS 2",
                excerpt="ROS 2 (Robot Operating System 2) is a set of software libraries...",
                url="https://example.com/docs/ros2-intro"
            ),
            SourceDocument(
                document_id="source-doc-2",
                title="Physical AI Foundations",
                excerpt="This chapter explores the foundational concepts of physical AI...",
                url="https://example.com/docs/physical-ai"
            ),
        ]
    else:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Chatbot response with ID '{response_id}' not found."
        )

@router.get("/chat/history", response_model=List[Message])
async def get_chat_history(
    user_id: str,
    session_id: Optional[str] = None
):
    """
    Retrieve conversational history for a user/session.
    """
    # In a real scenario, this would query a database for chat history.
    # For now, filter mock_chat_history based on user_id and session_id.
    
    # We will simulate a simplified session tracking.
    # In a real system, messages would be stored with user_id and session_id.
    filtered_history = [
        msg for msg in mock_chat_history 
        if msg.text and # Ensure message text is not empty
        "user" in msg.text.lower() # Simple filtering based on the mock data
    ]

    # If session_id is provided, further filter.
    # Currently, mock_chat_history doesn't explicitly have session_id per message,
    # so this filtering is conceptual for now.
    if session_id:
        # Placeholder for actual session_id filtering logic
        pass 
    
    return filtered_history

@router.post("/chat/feedback", status_code=status.HTTP_202_ACCEPTED)
async def submit_feedback(request: FeedbackRequest):
    """
    Submit feedback on a chatbot response.
    """
    # In a real scenario, this would store the feedback in a database.
    # For now, we'll just print it.
    print(f"Received feedback for response '{request.response_id}': Type='{request.feedback_type}', Comment='{request.comment}'")
    return {"message": "Feedback accepted."}

